


https://notepad-plus-plus.org/downloads/v8.6/


task 1:- write a program for printing below pattern 
===================================================================
*
**
***
****
*****
******
*******
********
*********
**********


tsk 2 :- write a pogram to print below pattern.
===================================================================
*****
****
***
**
*


tsk 3 :- write a pogram to print below pattern.
===================================================================

     *
    * *
   * * *
  * * * *
 * * * * *
 
-----*
----* *
---* * *
--* * * *
-* * * * *
 
     *
    * *
   * * *
  * * * *
 * * * * *	 

tsk 4 :- write a pogram to print below pattern.
===================================================================

     *
    * *
   * * *
  * * * *
 * * * * *
  * * * *
   * * *
    * *
     *
	 	 
task 5 :- write a program to calculate Sum  / write a program for sum functionality of a calculator.
======================================================================================================================================
package test;

public class Calculator {
	
	 public int sum(int input1, int input2)
	 {
		 int result=0;
		 
		 result=input1+input2;
		 
		return result; 
	 }
	 	
	public static void main(String[] args) {
		
		int input1=10;
		int input2=20;
		int result=0;
		
		Calculator cal=new Calculator();
		result=cal.sum(input1, input2);
		
		
		System.out.println("sum is :="+result  );
		
	}

}


Task 6 :- while loop demo.
===================================================================
package patterns;

public class WhileLoopDemo {

	public static void main(String[] args) {
		
		int i=0;
		int j=5;
		
		while(j>=0)
		{
			i=0;
				while(i<=j)
				{
					System.out.print("*");
					i++;
				}
			
			j--;	
			System.out.println();
				
		}

	}
}


Task 7 :-  User Input demo.
===================================================================
package executor;

import java.util.Scanner;

import patterns.PrintStarPattern;

public class PatternExecutor {

	public static void main(String[] args) {
		
		int constantUserInput=10;
		
		System.out.println("Please enter input :- ");
		Scanner sc= new Scanner(System.in);
		
		int userInput = sc.nextInt();
		
		PrintStarPattern psp=new PrintStarPattern(); // Object Creation.	
		psp.print(5);   // Method Call.
		
		System.out.println("----------------------------------------------");
		
		psp.print(constantUserInput);
		
		System.out.println("----------------------------------------------");
		psp.print(userInput);
		
	}

}


package patterns;

public class PrintStarPattern {

	int patternLevel;
	
	
	
	/*
	line 13 to 16 :- Method Defination..
	line 14:- Method Heading.
	
	Method heading contains Method name, return type , access modifier, and input parameters.
	*/
	
	public void print(int userInput)      // Method Heading.
	{
		
		System.out.println("user input is:- "+userInput);
		
		
		for(int j=userInput; j>=0;j--)
		{	
			for(int i=1;i<=j;i++)
			{
				System.out.print("*");
			}
			
			System.out.println();
		}
		
		
	}	
	
	
}



Task 8 :-  Constructors, constructor and method overloading.
===================================================================
package calc;

public class Calculator {

	int a,b,result; // data member.
	
	public Calculator()
	{
		//constructors are used to assign default values to data members(variables.).
		
		System.out.println("I am in default constructor....");
		a=10;
		b=20;
		result=0;
	}
	
	public Calculator(int input1, int input2)
	{
		System.out.println("I am in parameterized constructor....");
		a=input1;
		b=input2;
		result=0;
	}
	
	public void sum()
	{
		result=a+b;
	}
	
	
	public void sum(int input1, int input2) // overloaded method.
	{
		//in method overloading:- in same class , method name will be same, method parameters could be different. and return type also could be different.
		result=input1+input2;
		System.out.println("input1:-"+input1+" input2:-"+input2+" result:-"+result);
	}
	
	
	public void printOutput() // method
	{
		System.out.println("value of a := "+a+" value of b:="+b+" result:-"+result);
	}
	
}


package executor;

import calc.Calculator;

public class ConstructorDemo1 {

	public static void main(String[] args) {
		
		Calculator cal=new Calculator();

		cal.printOutput();
		cal.sum();
		cal.printOutput();
		cal.sum(5, 4);
		//cal.sum(5,4.2);
		
		Calculator cal1=new Calculator(11,22);
		cal1.sum();
		cal1.printOutput();
	}

}



Q) What is Class ?
--> Class is a collection of Data Members and Member Methods.

Q) What is Object ?
--> Object represents one instance of a class.
--> Object is one instance of a class.


Q) What is Constructor ?
--> Constructors are used to assign default values to data members of same class.

Q)What is Data Member in a class ?
--> Data Member is a variable declared at class level.

Q) What are OOPS Concepts.
--> 







Task 9 :- Homework.
===================================================================

create a class named Vehicle which should me having details of number, ownername, color, company, model;
create default and all parameterized constructor.





Task 10 :-  Swapping Values, Swapping Values without using 3rd variable.
===================================================================================



swapping values
--------------------------------------------

package interviewtasks;

public class SwappingValues {

	public static void main(String[] args) {
	
		int n1= 10;
		int n2= 20;
		
		int temp=0;
		
		System.out.println("before swapping n1:="+n1+" n2:="+n2);
		
		temp=n1;
		n1=n2;
		n2=temp;
		
		System.out.println("after swapping  n1:="+n1+" n2:="+n2);
		
		

	}

}


Swapping values without using 3rd variable.
----------------------------------------------------

package interviewtasks;

public class SwappingWithourUsingThirdVariable {

	public static void main(String[] args) {
		
		int n1= 10;
		int n2= 20;
		
		System.out.println("before swapping n1:="+n1+" n2:="+n2);
		
		n1=n2+n1;   //n1=30 
		n2=n1-n2;   // n2=10
		n1=n1-n2;
		
		System.out.println("after swapping  n1:="+n1+" n2:="+n2);
				
	}

}



fibonacci Series
-----------------------------------------

package interviewtasks;

public class FibonacciSeries {

	public static void main(String[] args) {
		
		
		// 0 1 1 2 3 5 8 13;
		
		
		int num1=0;    //   0   1    1
		int num2=1;		//  1    1    
		
		int fibSeries=0;  //  1  2
		
		System.out.print(num1+" "+num2);
		
		for(int i=0;i<=50;i++)
		{
			 fibSeries = num1 + num2;  
			 num1=num2;
			 num2=fibSeries;
			
			 System.out.print(" "+fibSeries);			 
		}		
		
	}

}


Task 11 :-  Swapping Values, Swapping Values without using 3rd variable.
===================================================================================




Task 12 :-  how would you represent a laptop / computer in java to represent Company name, model, processor, display size, price etc.
===================================================================================


Task 13 :-  inheritance demo..
===================================================================================

//package base;
package base;

public class A {

	
		int i;

		public A()
		{
			System.out.println("i am in default constructor of A class....");
			i=100;
			
		}
		
		
		public A(int input_i)
		{
			System.out.println("i am in single param constructor of A Class....");
			this.i=input_i;
		}
		
		public int getI() {
			return i;
		}

		public void setI(int i) {
			this.i = i;
		}
		
		
	
}
//package derived;
package derived;

import base.A;

public class B extends A {
	
	int j;

	
	public B()
	{
		super(10);
		System.out.println("i am in Default constructor of B class....");
		j=200;
		
	}
	
	public B(int j)
	{
		super(1000);
		System.out.println("i am in single parma constuctor of B Class....");
		this.j=j;
		
		
	}
	
	public int getJ() {
		return j;
	}

	public void setJ(int j) {
		this.j = j;
	}
	

}


/package executor;
package executor;

import derived.B;

public class InheritanceDemo1 {

	public static void main(String[] args) {
		

			B b=new B();
			B b1=new B(20);
			
			
			System.out.println(b.getI()+" "+b.getJ());
		
	}

}




Q) what are methods in Object class.



Task 14 :-  StaticDemo..
===================================================================================

package products;

public class Product {

	
	// instance data members. instance is nothing but an object.
	// instance variables will be initialized at time of creating an object of a class. or calling new ClassName();
	float price;
	int quantity;	
	String productName,seller,warrenty;
	
	
	
	// static values are for storing fix information which could be accessible without creating an object.
	// these are initilized at time of loading class in jvm.
	public static String deliveryTime="3days";
	
	
	
	
	public Product()
	{
		productName = "iphone 14";
		price = 150000.50f;
		seller = "Some Mobile Store";
		warrenty = "1 year ";
		quantity = 500;
	}

	public Product(float price, int quantity, String productName, String seller, String warrenty) {
		super();
		this.price = price;
		this.quantity = quantity;
		this.productName = productName;
		this.seller = seller;
		this.warrenty = warrenty;
	}

//generate getter and setter methods here..............
//generate getter and setter methods here..............
//generate getter and setter methods here..............


// generate toString method here...........


}



package executor;

import products.Product;

public class ProductExecutor {

	public static void main(String[] args) {
		

			
		String info=Product.deliveryTime;
		String info1= Product.getDeliveryTime();
		
		System.out.println(info);
		System.out.println(info1);
		
		

		Product p1;   // declare an object of a Product class.
		p1=new Product();  // here we initialized / created object.
		p1.getPrice();
		
		p1.getDeliveryTime();  // we can call static method w.r.t.object of a class.
		
		//Product.getProductName() // we cannot call like this.
		
	}

}



Task 15 :-  Static Data Members Calling..
===================================================================================


package executor;

public class StaticDataMembersCalling {

	public String info="welcome to java world :- instance variable...!";
	
	public static String info1="welcome to java world :- static variable...!";
	
	
	public static void main(String[] args) {
		
		B();
		
		
		StaticDataMembersCalling sdmc=new StaticDataMembersCalling();
		sdmc.A();
		
		
		
	}

	public void A()
	{
		System.out.println("------------------i am in instance A() method....----------------------------");
		// instance variable call be called directly without obect if they belong to same class..
		System.out.println("info:- "+info);
		// static variable can also be called directly without object if they belong to same class. from instance mthod context.
		System.out.println("info1:-"+info1);
	
	}
	
	public static void B()
	{
		System.out.println("------------------i am in static B() method....----------------------------");
		// instance variable cannot be called directly from context of a static method. provided both method and variable belong to same class.
		//System.out.println("info"+info);    // uncomment this line before running first time..//
		
		//static variable can be called directly from context of static method. provided both method and variable belong to same class.
		System.out.println("info1"+info1);
		
	}
	
	
	
	
}



Task 16 :-  Static Methods Calling..
===================================================================================
package executor;

import products.Product;

public class StaticMethodCalling {

	
	
	
	
	public static void main(String[] args) {
		
	
		
		//Scenario 1.....
		//one static method can call other static method directly provided both are in same class.. 
		// i.e. we don't need object to call methods in same class.
		A();
		//B();
		//we cannot call instance method of SameClass from static method...		
		//C();
		//D();
		//instance method of SameClass can be called w.r.t. SameClass Object.
		StaticMethodCalling smc=new StaticMethodCalling();
		smc.C();
		
		//static method of OtherClass can be called w.r.t. ClassName.methodName()
		String deliveryTime=Product.getDeliveryTime();
		
		//static method of OtherClass can be called w.r.t. Other Class Object.
		
		Product p=new Product();
		System.out.println(p.getProductName());
			
		
		
	}

	public static void A()
	{
		B();
		System.out.println("i am in A method...");
	}
	
	public static void B()
	{
	
		System.out.println("i am in B method....");
	}
	
	
	public void C()
	{
		D();
	 System.out.println("i am in C method.....");	
	}
	
	public void D()
	{
	 System.out.println("i am in D method.....");	
	}
	
}





OOPS Concepts
==============================

1) Abstraction :- Hiding the complex implementation details and providing interface(interface here is general english term .) to access functionality is Abstraction. e.g. phone call. Opening a bank Account.
or 

Hiding data  members with Private keyword from outside world. and only allowing them to access by using getter and setter methods is abstraction. here getter and setter method act as an interface.
e.g. starting a car , operating a bank account...

2) Encapsulation  :- Binding Data Members and Member Methods in single unit is called Encapsulation. Class is Result of Encapsulaiton.


3) Polymorphism   :- Static Polymorphism and Dynamic Polymorphism
poly means:- many
Representing one thing in many forms is Polymorphism.

Method overloading :- same method with same name and different signature in same class is method overloading.
Method overriding :-  same method with same name and different signature in derived class is method overriding.

Method overloading is example of Static Plymorphism. in method overloading, methods are bound with object at compile time.
Method Overriding is example of Dynamic Polymorphism. in method overriding,  methods are bound with object at run time. 

4) Inheritance    :- 

allowing access to data members and member methods in sub class  or extended class is called as inheritance. java supports Single, Multi Level,Hirarchial inheritance.
Multiple inheritance is not supported in java in terms of class.


or allowing access to data members and member methods in other class without creating its object is called as inheritance.




Task 16 :-  Method Overloading  and Overriding  and Inheritance and Polymorphism...
===================================================================================

package base;

public class BaseClass {

	public void sum(int i, int j)
	{
		System.out.println("int value sum in base class is "+i+j);
	}
	
	// overloaded method...
	
	public void sum(float i, float j)
	{
		System.out.println("sum is "+i+j);
	}
	
	
}

package derived;

import base.BaseClass;

public class DerivedClass extends BaseClass{

	
	@Override
	public void sum(int i, int j)
	{
		// sice derived class cannot call base class orignal method w.r.t. object , we can call orignal method with help  of super.methodname.
		  
		 System.out.println("int value sum in derived class...===================>"+(i+j)) ;
		 super.sum(i,j);
		
	}
	
	
	public void sum(double i, double j)
	{
		System.out.println("double value sum is := "+(i+j));
	}	
}

package executor;

import derived.DerivedClass;

public class OverloadingOverridingExecutor {

	public static void main(String[] args) {
		
		
		
		DerivedClass dc=new DerivedClass();
		
		dc.sum(1.1, 1.1);
		dc.sum(2.2f, 2.2f);
		
		dc.sum(0, 0);

	}

}





Task 17 :-  primitive datatypes vs Object data types ?
===================================================================================


byte, int ,long, float , double , boolean, char,  ----> Premitive Datatypes...



Q)is java pure object oriented language ? 
--> NO, because java supports primitive datatypes. hence java is not pure object oriented programing lang.
we can make use of Object datatypes and make 100% object oriented programming using java.



Integer, Long , Float, Double, Boolean, Char

non primitive data types should be preffered, because we will be able to use mehtods present in Object datatypes classes. and perform operation on data.


Primitive types are predefined (already defined) in Java. Non-primitive types are created by the programmer and is not defined by Java (except for String).
Non-primitive types can be used to call methods to perform certain operations, while primitive types cannot.
A primitive type has always a value, while non-primitive types can be null.


Immutability: Primitive data types are immutable, meaning their values cannot be changed once assigned. When you modify a variable of a primitive type, you are creating a new value.



Task 18 :-  Abstract Class Demo. ?
===================================================================================


//Concrete class structure example.

class SomeClassName
{

	instance variables;
	static variables;
	
	final instance variables;
	final static variables  
	
	
	constructors();
	
	
	instance methods();
	static methods();
	

}

/* 

------------------------------
Abstract Class....
------------------------------

--> what is concrete class ?--->  Concrete class is class with all defined methods...or having every method implemented..

---> Abstract class should contain zero or more abstract method.....
 abstract class is a class that contain zero or more abstract method.

---> Abstract method is undefined method.... or method with only method heading and doesen't have mehtod body is abstract mehod.
or we have to declare such methods abstract that are not having body....

---> abstract methods are supposed to be implementd by someone who is extending that abstract class....

---> derived class of abstract class is implementaiton class of abstract class..

*/

// abstract class structure example...
abstract class SomeAbstractClassName
{
	  //abstract method...
	public abstract String method1();
	
	//abstract method..
	public abstract void method2();

	
	
	//implemented method.... or non abstract method...
	public void method3()
	{
	
	}
	
}


class DerivedClass extends SomeAbstractClassName // 
{

	public String mehod1()
	{
		some operations...
		
		return string-value;
		
	}
	
}



Task 18
-------------
package base;
public abstract class Shape {

	 public abstract void draw();
	
}


package shapeimplementations;

import base.Shape;

public class Triangle extends Shape{

	@Override
	public void draw() {
		
		System.out.println("i am drawing Tringle...");
	}	
}


package shapeimplementations;

import base.Shape;

public class Triangle extends Shape{

	@Override
	public void draw() {
		
		System.out.println("i am drawing Tringle...");
	}
}


package shapeimplementations;

import base.Shape;

public class Circle extends Shape {

	@Override
	public void draw() {
		
		System.out.println("i am drawing Circle....");
	}
}

package shapeexecutor;

import base.Shape;
import shapeimplementations.Circle;
import shapeimplementations.Triangle;

public class ShapeExecutor {

	public static void main(String[] args) {
		
		// we cannot create object of Shape class because it is Abstract class..
		//Shape shape=new Shape();
		Shape s;
		
		s= new Triangle();	
		s.draw();
		
		s= new Circle();
		s.draw();
		
		
		Triangle t1 =new Triangle();
		t1.draw();
		Circle c1=new Circle();
		c1.draw();
	}

}


class ClassName
{

}

------------------------------
Interface Class....
------------------------------

Interface :- is collection of public static final data members and abstract methods only.
Abstract class :- contains zero or more abstract methods and data members.

interface InterfaceName   
{

		// interface have only public static final variables.
		public static final double pi=3.14; 
		int i;
		
		
		public void draw();
		public String print();
		// interface doesn't have constuctors...
}


InterfaceName in =new InterfaceName();    -----> this is incorrect .. not allowed..



interface is supposed to be participating in inheritance...

class ImplementationClass implements InterfaceName
{

		public void draw();
		{
				.....
		}
		
		public String print()
		{
			......
		}

}






interface 
	|
	|
abstract class
	|
	|
  class ---> implementation provided by all db software vendors.....



Q) What is base class of all classes in java ?
----> Object is base class of all classes in java..

Q) What are Structured DB's you know ?
-->MySQL, Oracle, SqlServer H2 db,PostgreSQL



Java ---> JDBC(API)[Contains interfaces and Abstract classes...]

mysql --> implementation of jdbc ---> mysql-connector-jar
oracle ----> implementation of jdbc  ---> Ojdbc.jar



what is jar ----> java archive...
--> when we want to share our code / implemnetation code , we export our application as jar file.

iterators.co.in





in.co.iterators.vehicle
in.co.iterators.executor
com.mysql.jdbc.driver


Task 19
-------------

package interviewtasks;

public class StringOutputTracing {

	public static void main(String[] args) {
		

		
		String str="hello";
		String str1="hello";
		
		String helloString=new String("hello");
		String helloString1=new String("hello");
		

		System.out.println(str==str1);  // --> true  // compares address in ==......
		
		System.out.println(str==helloString);  // --> false // compares address. in ==
		
		System.out.println(str.equals(str1));  // --> true  // compares content
		
		System.out.println(str.equals(helloString)); //   true		// compares content
	
		System.out.println(helloString==helloString1);   // -----> false // compares address
		
		System.out.println(helloString.equals(helloString1));  // ---> true // compares content.
		
		
		
	}

}





Task 19  :- String Operations
---------------------------------

package interviewtasks;

public class StringOperations {

	public static void main(String[] args) {
		
		
		String name="Vijay Dinanath Chouhan";
		
		System.out.println("String Length:- "+name.length());
		System.out.println("7 th character is :- "+name.charAt(6));
		
		System.out.println("Dina index is "+name.indexOf("Dina"));
		System.out.println("first i index is :- "+name.indexOf('i'));
		System.out.println("Last i Position is :- "+name.lastIndexOf('i'));
		
		System.out.println("firsti position(index) is "+name.indexOf("i"));
		System.out.println("Last i position is :-"+name.lastIndexOf("i"));
		
		System.out.println("a is replaced by b:- "+ name.replace('a', 'b'));
		System.out.println("a is replaced by b:- "+ name.replace("ij", "jk"));
		System.out.println("All a is replaced by b:- "+name.replaceAll("a", "b"));
		
		System.out.println("UpperCase "+name.toUpperCase());
		System.out.println("LowerCase "+name.toLowerCase());
		System.out.println("starts with Vijay:- "+name.startsWith("Vijay"));
		System.out.println("ends with han:- "+name.endsWith("han"));
		
		
		System.out.println("Sustring is :-"+name.substring(7));
		System.out.println("Sustring is :-"+name.substring(name.lastIndexOf('i')));
		
		
		System.out.println(name.concat("  gaon :- Mandva") );
		System.out.println(name+"  gaon :- Mandva");
	}

}



Task 20 :- String reverse
---------------------------------



package interviewtasks;

public class StringReverseDemo {

	public static void main(String[] args) {
	
		
		String name="Vijay Dinanath Chouhan";
		
		String reversedName="";
				
		int nameLength=name.length()-1;
				
		System.out.println("name length is "+nameLength);

		for(int i=nameLength; i>=0;i--)
		{		
			System.out.println(name.charAt(i) );
			reversedName= reversedName+name.charAt(i);
		}
					
		System.out.println("reversed Name is "+reversedName);
		
	}

}





Task 21 :- UserDefined Exception
---------------------------------


Exception
{
String message;

public Exception( String message)
{
	this.message=message;
}

}

nameArray=[0|1|2|3]

String nameArray []={'suraj','shweta','pratiksha','tanu'}


nameArray[4];




InvalidInputException  -----> Exception 
NumberFomatException   -----> Exception
ArrayIndexOutOfBoundException  -----> Exception
StringIndexOutOfBoundException ------> Exception

Exception e;


e = new InvalidInputException("message....");

e = new NumberFomatException("message....1");

e = new ArrayIndexOutOfBoundException("message....1")

e = new StringIndexOutOfBoundException("message....1")


Task 22 :- throwing exception.
----------------------------------

package exceptiondemos;

import java.util.Optional;
import java.util.Scanner;
import java.util.regex.Pattern;

public class ExceptionDemo1 {

	public static void main(String[] args) {
	
		int x=0;
		System.out.println("Please enter number :- ");
		Scanner sc= new Scanner(System.in);
		
		String input= sc.next();
					
		 try {
		   
			boolean isValidUserInput=isValidInt(input);
			
			
			// if exception is thrown by isValidInt method, below code in this try block will not be executed.
			 if(  isValidUserInput)
			 {
				   x = Integer.parseInt(input);
				 
			 }
			  
			 System.out.println("aaaa");
			 System.out.println("bbbbbb");
			 
			 
		 }
		 catch(Exception e) {    //  catch(InvalidInputException e) {
		 
			 System.out.println( e.getMessage() );
			
				 
		 } 	
		 finally
		 {
			 
			 // this block gets executed compulsory irrespective of  exception is thrown or not..
			 sc.close();
		 }
			
	}

		
	 public static boolean isValidInt(String input) throws InvalidInputException
	 {
		 
		 
		 boolean validInt=false;
		 Pattern pattern = Pattern.compile("-?\\d+(\\.\\d+)?");
		 
		 
		 input=input.trim();
		  
		 System.out.println("Entered input is "+input);
		 
		 if(input == null)
		 {
			 return validInt;
		 }	 
		 else if(input.length()==0)
		 {
			 return validInt;
		 }
		 else if(  ! pattern.matcher(input).matches())
		 {
			 
			 //throws exception.
			throw new InvalidInputException("please enter valid integer....!");
						 
		 }
		 else
		 {
			 validInt=true;
		 }
		 
		 
		 
		 return validInt;
	 }
	
}



package exceptiondemos;

public class InvalidInputException extends Exception{
	
	

	public InvalidInputException(String message)
	{	
		super(message);
	}
	
}


Arrays
---------------------------------------------------------------------------------------
problems with Arrays
---------------------------
1) we cannot modify array's once they are created.
2) once declared, we can only insert that declared type of values to array indexes.. 




Char [] charArray={'a','b,'c'}
Char [] charArray=new char[10]

charArray[0] -----> a
charArray[1] -----> b

charArray[1]='i';



Task 23 :- Base class and DerivedClass object refferences method calling consequences...
------------------------------------------------------------------------------------------------------


BaseClass
{

int a;

p v m1();


}


DerivedClass  extends BaseClass
{
int b;

p v m2();

}


Base baseClassObject =new Base();    // base class object is assigned base class reference  ---> valid. you will be able to call only base class methods.

Base baseClassObject = new DerivedClassObject();    // base class object is assigned derived class refference...  ----> valid.. but you will be able to call only base class methods....


DerivedClas derivedClassObject = new DerivedClassObject();    // derived class object is assigned derived class reference. ----> valid.. here you will be able to call both base can derived class methods.

DerivedClassObject derivedClassObject = new Base();   // derive class object is assigned with base class reference. ----> invalid  . type casting resolves compilation errors, but will get runtime error.



Collection
=====================================================



1D:- 

char [] charArray = new char[10];
char[][] charArray1 =new charArray1[3][3];



charArray[1,2,3,4,5,6,7,8,9,10]


 			1 2 3
charArray1= 4 5 6
		    7 8 9




1D collection :-   list  and set 


list:-   [water bottle, cooker ,tv, water bottle.] 
set :- {water bottle, cooker,tv}
stack :-  push and pop ---> first come last out..   
Queue :-  first come last out.





Task :- 24 LinkedList demo
=========================================================

package onedcollection;

import java.util.LinkedList;
import java.util.List;

public class LinkedListDemo {

	public static void main(String[] args) {
	
		LinkedList ll= new LinkedList();
		
		ll.add(10);
		ll.add("Suraj");
		ll.add(411057);
		ll.add("pune");
		
		System.out.println(ll.getFirst());
		System.out.println(ll.getLast());
		
		System.out.println(ll.get(3));
		
		ll.addFirst("java");
		ll.addLast("python");

		System.out.println(ll);	
		
	}
}



Task :- 25 ArrayList demo
=========================================================
package onedcollection;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;

public class ArrayListDemo {

	
	public static void main(String args[])
	{
			
		ArrayList al =  new ArrayList();
	
		List l = new LinkedList();	 // for demonstration.
			
		al.add(10);
		al.add("Suraj");
		al.add(411057);
		al.add("pune");
		
		System.out.println("ArrayList elements are "+ al);
		
		al.add(1,"Dist Pune");
		
		System.out.println("ArrayList elements are "+ al);
		
		ArrayList al1= (ArrayList) al.clone();
		
		System.out.println("AL1 "+al1);
		
		al1.clear();
		
		System.out.println("AL1 after clear "+al1);
		System.out.println("AL after clear "+al);
		
		System.out.println("ArrayList contains element 'Suraj' or not :- "+al.contains("suraj") );
		
		al.add(null);
		al.add(null);
		
		System.out.println("AL after clear "+al);
		
		
		
		Iterator itr= al.iterator();
		
		for(int i=0; i<al.size(); i++)
		{
				if(itr.hasNext())
				{
			
					System.out.println(itr.next());  
				
				}
		}
		
		ListIterator li=	al.listIterator();
		Iterator itr1= al.iterator();
	
	}
	
}



Task :- 26 TreeSet demo
=========================================================
package onedcollection;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.TreeSet;



public class TreeSetDemo {

	public static void main(String[] args) {
		
		
		TreeSet ts=new TreeSet();
		//Set s= new TreeSet();
		//s =  new HashSet();
		
		System.out.println("treeset elements are "+ts);
		
		ts.add(3);
		ts.add(1);
		ts.add(4);
		ts.add(1);
		ts.add(2);
		
		System.out.println("treeset elements are "+ts);

		Iterator itr = ts.iterator();
		
		while(itr.hasNext())
		{
				System.out.println(itr.next());
		}
		
	}

}



Task :- 27 HashSet demo
=========================================================
package onedcollection;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public class HashSetDemo {

	public static void main(String[] args) {
		
		
		
		//HashSet hs =new HashSet();
		
		Set hs = new HashSet();
	
		/*	
		//hs.add(10);
		hs.add("Suraj");
		hs.add(411057);
		hs.add("pune");
		hs.add(null);
		*/
		hs.add(4);
		hs.add(1);
		hs.add(2);
		hs.add(3);
		hs.add(4);
		
		System.out.println(hs.toString());
		//System.out.println(hs); // same as calling toString method.
		
		// hashSet doesen't allow duplicate elements.
		
		//hs.add(10);		
		//hs.add(null);
		
		Iterator itr=hs.iterator();
		
		while(itr.hasNext())
		{
			System.out.println(itr.next());
		}
		
		
		
	}

}




Task :- 28 ConcurrentModificationExceptionDemo
=========================================================

package onedcollection;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class ConcurrentModificationExceptionDemo {

	public static void main(String[] args) {
		
		
		List al = new ArrayList();
		
		al.add(10);
		al.add("Suraj");
		al.add(411057);
		al.add("pune");
		
		System.out.println("ArrayList elements are "+ al);
		
		al.add(1,"Dist Pune");
		
		System.out.println("ArrayList elements are "+ al);
		
		
		Iterator itr= al.iterator();
		
		al.remove(2);
		
		while (itr.hasNext()) {

				System.out.println("next element --> "+itr.next());
				
				itr.remove();
				System.out.println("all elements are -------------->"+al);
				//System.out.println("next element --->"+itr.next());						
				
		}

		
	}

}



Task :- 29  HashMapDemo 
=========================================================
package twodcollection;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

public class HashMapDemo {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		HashMap hm = new HashMap();
		
		//Map hm1= new HashMap();
		
		//Map hm2= new TreeMap();
		
		
		
		hm.put(1, "Car");
		hm.put(2,"Bus");
		hm.put(3,"Tempo");
		hm.put(4, "Airoplane");
		hm.put("Suraj","Car");
		
		System.out.println("hm elements are "+hm);		
		Set hmKeySet =hm.keySet();			
		System.out.println("hmKeySet is "+hmKeySet);		
		System.out.println("get(1) :- "+hm.get(1) );		
		Iterator hmIterator =hmKeySet.iterator();
				
		System.out.println("printing hm iterator elements");
		
		while (hmIterator.hasNext())
		{			
			System.out.println(hmIterator.next());
		}
		
		
		System.out.println("=========================snd method to retrive lements =================");
		
		Set entrySet=hm.entrySet();		
		System.out.println("entry set is"+entrySet); 		
		Iterator entrySetIterator =entrySet.iterator();		
		while(entrySetIterator.hasNext())
		{
			System.out.println( entrySetIterator.next() );
		}	
			
		
		System.out.println("====================Remove element======================");
		hm.remove("Suraj");
		
		System.out.println("after removal elemtns are "+hm);
		
	}

}


Task :- 30 TreeMapDemo
=========================================================



package twodcollection;

import java.util.Iterator;
import java.util.Set;
import java.util.TreeMap;



public class TreeMapDemo {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		
		TreeMap tm = new TreeMap();
		/* note that when you put first element key , rest of the keys should be of same types. like integer
		 we can use multiple null values associated with different keys.
		 treemap will not accept null as key.
		*/
		//tm.put(null, 1);
		tm.put(1, null);
		tm.put(2, "killari");
		tm.put(3,null);
		
		System.out.println("treemap elements are "+tm);		
		System.out.println("tm.get(2):- "+tm.get(2));		
		Set keySet=tm.keySet();		
		System.out.println("keyset is "+keySet);
		
		System.out.println("=========retrive elements ==========>");
		
		Iterator itr =keySet.iterator();
		
		while(itr.hasNext())
		{
			System.out.println("--->"+itr.next());
		}
		
		
		System.out.println("=========remove element ==========>");
		tm.remove(3);
		System.out.println("after removal "+tm);
		
		// adding 1 key-value.
		tm.put(5, "New York");
		
		System.out.println("");
		
		
		System.out.println("containsKey(3) ? "+tm.containsKey(3));
		System.out.println("containsKey(3) ? "+tm.containsKey(5));
		
	}

}




Task :- 30 BubbleSort sorting array elements.
=========================================================

{7,1,3,2,6,4,8,5,0,9}
{1,3,2,6,4,7,8,5,0,9}


package interviewtasks;

import java.sql.Time;

public class SortingIntegerArray {

	public static void main(String[] args) {
		
		//int []a= {7,1,3,2,6,4,8,5,0,9};  		
		
		int []a= {7,1,3,2};  
		
		
		System.out.println(a.length);
		
		int b,c,arrayLength;
		
		arrayLength=a.length;
		
		for(int i=0;i<10;i++)
		{
			System.out.print(a[i]);
		}
			
		
		for(int j=0;j<arrayLength;j++) 									
		{
			for(int i=0;i<arrayLength-j-1;i++)    // i<1//===> 0
			{
				//System.out.println(a[i]);			
				b=a[i];
				c=a[i+1];
						
				if(b>c)        // a[0] > a[1]  ? --> false
				{									
					a[i]= c;
					a[i+1]=b;			
				}	
							
			}
		}
		
		System.out.println();
		
		
		for(int i=0;i<10;i++)
		{
			System.out.print(a[i]);
		}
	
	}

}



Task :- 31 sorting Arraylist of Student class objects.
=========================================================



package student;

public class Student implements Comparable<Student>{


	int rollNo;    
	String name;
	String std;
	
	final static double pi=3.14;
	
	
	
	public Student()
	{
		//System.out.println("i am in default Constructor....");
		this.rollNo=0;
		this.name="no-name";
		this.std="0";
	}
	
	
	public Student(int rollNo,String name)
	{
		//System.out.println("i am in 2 parameterized Constructor....");
		this.rollNo=rollNo;
		this.name=name;
		this.std="1";
	}
	
	public Student(int rollNo,String name, String std)
	{
		//System.out.println("i am in 3 parameterized Constructor....");
		this.rollNo=rollNo;
		this.name=name;
		this.std=std;
		
	}

	// getXXXX() :- are called getter method.
	// setXXX() :- are called setter method.
	
	
	public int getRollNo() {
		return rollNo;
	}
	public void setRollNo(int rollNo) {
		this.rollNo = rollNo;
	}

	//this :- represent current class data member.
	// this is provided in java to distinguish between current class data members and input parameters in member methods or constructors..
	
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getStd() {
		return std;
	}
	public void setStd(String std) {
		this.std = std;
	}


	@Override
	public String toString() {
		return "Student [rollNo=" + rollNo + ", name=" + name + ", std=" + std + "]";
	}
	

	public boolean equals(Student inputStudent)
	{
		boolean isEqual=false;
		
		if(this.rollNo==inputStudent.rollNo)
		{
			isEqual=true;
		}	
		
		return isEqual;
	}


	@Override
	public int compareTo(Student inputStudent) {
	
	int returnValue=0;
		
		if(this.rollNo == inputStudent.rollNo)
		{
			returnValue=0;
		}
		else if(this.rollNo > inputStudent.rollNo)
		{
			returnValue=-1;
		}
		else if(this.rollNo < inputStudent.rollNo)
		{
			returnValue=1;
		}
		
		return returnValue;
		
		
	}
	

}



package executor;

import java.util.ArrayList;
import java.util.Collections;

import student.Student;

public class NewTest {

	public static void main(String[] args) {
		
		Student s1=new Student(1,"Suraj");
		Student s2=new Student(2,"Shweta");
		Student s3=new Student(3,"Tanuja");
		Student s4=new Student(4,"Anay");
		Student s5=new Student(5,"Supriya");
		
		
		System.out.println(s1.compareTo(s2));
		System.out.println(s2.compareTo(s1));
		
		ArrayList al = new ArrayList();
		
		al.add(s1);
		al.add(s5);
		al.add(s2);
		al.add(s4);
		al.add(s3);
		
		System.out.println(al);		
		Collections.sort(al);
	
		System.out.println(al);
		
	}

}


Task :- 32 
=========================================================


d:\\folder1\folder2\abc.txt








































